<!DOCTYPE html>












  


<html class="theme-next muse use-motion" lang="zh-CN">
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
























<link rel="stylesheet" href="/blog/lib/font-awesome/css/font-awesome.min.css?v=4.6.2">

<link rel="stylesheet" href="/blog/css/main.css?v=7.1.0">


  <link rel="apple-touch-icon" sizes="180x180" href="/blog/images/apple-touch-icon-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="32x32" href="/blog/images/favicon-32x32-next.png?v=7.1.0">


  <link rel="icon" type="image/png" sizes="16x16" href="/blog/images/favicon-16x16-next.png?v=7.1.0">


  <link rel="mask-icon" href="/blog/images/logo.svg?v=7.1.0" color="#222">







<script id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/blog/',
    scheme: 'Muse',
    version: '7.1.0',
    sidebar: {"position":"right","display":"always","offset":12,"onmobile":false,"dimmer":false},
    back2top: true,
    back2top_sidebar: false,
    fancybox: false,
    fastclick: false,
    lazyload: false,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>


  




  <meta property="og:type" content="website">
<meta property="og:title" content="wks藏在这里">
<meta property="og:url" content="http://yoursite.com/blog/index.html">
<meta property="og:site_name" content="wks藏在这里">
<meta property="og:locale" content="zh-CN">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="wks藏在这里">





  
  
  <link rel="canonical" href="http://yoursite.com/blog/">



<script id="page.configurations">
  CONFIG.page = {
    sidebar: "",
  };
</script>

  <title>wks藏在这里</title>
  












  <noscript>
  <style>
  .use-motion .motion-element,
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-title { opacity: initial; }

  .use-motion .logo,
  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-CN">

  
  
    
  

  <div class="container sidebar-position-right 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta">
    

    <div class="custom-logo-site-title">
      <a href="/blog/" class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">wks藏在这里</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
    
    
  </div>

  <div class="site-nav-toggle">
    <button aria-label="切换导航栏">
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>



<nav class="site-nav">
  
    <ul id="menu" class="menu">
      
        
        
        
          
          <li class="menu-item menu-item-home">

    
    
    
      
    

    

    <a href="/blog/" rel="section"><i class="menu-item-icon fa fa-fw fa-home"></i> <br>首页</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-about">

    
    
    
      
    

    

    <a href="/blog/about/" rel="section"><i class="menu-item-icon fa fa-fw fa-user"></i> <br>关于</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-tags">

    
    
    
      
    

    

    <a href="/blog/tags/" rel="section"><i class="menu-item-icon fa fa-fw fa-tags"></i> <br>标签</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-categories">

    
    
    
      
    

    

    <a href="/blog/categories/" rel="section"><i class="menu-item-icon fa fa-fw fa-th"></i> <br>分类</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-archives">

    
    
    
      
    

    

    <a href="/blog/archives/" rel="section"><i class="menu-item-icon fa fa-fw fa-archive"></i> <br>归档</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-schedule">

    
    
    
      
    

    

    <a href="/blog/schedule/" rel="section"><i class="menu-item-icon fa fa-fw fa-calendar"></i> <br>日程表</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-sitemap">

    
    
    
      
    

    

    <a href="/blog/sitemap.xml" rel="section"><i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br>站点地图</a>

  </li>
        
        
        
          
          <li class="menu-item menu-item-commonweal">

    
    
    
      
    

    

    <a href="/blog/404/" rel="section"><i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br>公益 404</a>

  </li>

      
      
    </ul>
  

  
    

  

  
</nav>



  



</div>
    </header>

    


    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/11/10/2019110/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/11/10/2019110/" class="post-title-link" itemprop="url">写于2019110</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-11-10 23:33:14 / 修改时间：23:36:47" itemprop="dateCreated datePublished" datetime="2019-11-10T23:33:14+08:00">2019-11-10</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="20191110"><a href="#20191110" class="headerlink" title="20191110"></a>20191110</h1><p>今天喝了挺多，想写写东西。<br>已经到年底了，也该写写总结啥的，但是转念一想，总结其实挺简单的，就是一个丧字贯穿了始终，丧的我真的好痛苦，我这一年用自己的身体力行支持了青岛啤酒厂，哈尔滨啤酒厂，但即使是这样，也依旧要在每天醒来，发现还是要面对新的一天，新的，让人没法开心的一天。<br>从今年年初开始，四月份，我鼓起勇气跳槽了，本以为我会至少跳的好一点，但是现实总是啪啪啪的打倒我，我非常不幸的跳了P2P ,刚入职两个星期就暴雷了 ，仔细想想，我为什么会跳这个P2P ,我只能感叹19年工作真的挺不好找的，又或是本命年我该有这么一劫，罢了，反正事情已经发生了，那天我喝了挺多，打了挺多电话，用戏谑的口气和朋友们说了这事。<br>这件事无疑增加了我19年的难度，我得和别人解释我为什么没有离职证明，解释我的社保为什么还没法转出。那几个星期挺难过的，我甚至接了外包的求职，甚至冲面试的人电话里发了火，两个星期后 ，我在压力下，没办法来了这里，我本来自信面试稳的很，但是我从一开始就挺怀疑自己能不能来，最后我终于来了，但是以外包的身份，来了之后才知道，自己恰好踩了这个坑，来了之后人家正式职位拒了offer,领导还安慰我说没关系，之后有机会转的。想想当时为什么没有立刻走，可能是因为没有工作这件事开始让我害怕了吧，可能事终于看到了互联网公司的架构让我想再多看几眼吧。总之我留下来了。  </p>
<p>其实在这本的工作四个月的时候，就已经了解了全局架构，工作已经开始重复，难以有进展，本来想这个月提一嘴换成内勤，但是老大恰好在这个星期换去别的组了，我这个本命年简直是踩了一个又一个的坑，真的是把不顺写在了这一年，到现在为止，我每天看着自己的非员工卡，每天早上进门都想一脚踹在门上，每次看着别人做事效率低，都想骂人，但我还能怎么样，我只能怪我自己命不好？我只能认真准备准备然后等着明年赶紧跳槽？从实习开始算我已经出来工作三年了，我真的挺悲伤我现在这个样子的，怎么就变成这样了那，我百分之70下班时间自己都在看东西，我敢说自己的视野， 技术水平是与我三年前后区间的人的前列水平，但是为什么就变成这样了那。</p>
<p>除了工作这个这几年最让我无奈的事 。我还想说说生活，其实我也不知道自己能在上海待多久，我最近已经在开始怀疑我究竟在外面漂泊这件事究竟对不对，我究竟在追求什么，追求钱？那程序员真的没办法做到这点，追求生活？好像也没有，前几天听到以前一个同事在考虑回家，挺让我羡慕的，本来我就很羡慕他，有好的见识，好的简历，出众的能力，现在更羡慕人家了，再看看自己，还不知道什么时候才能拥有自己的，让我开心点，让我觉得有所期盼的生活。  </p>
<p>其实写了这么多，我最想谈一点，就是最近那个姑娘，那个姑娘其实我一直就挺喜欢的，这次出去玩也挺让我惊讶的，她主动拉着我手，这让我这个万年单身狗感觉到了这两年最新鲜的感觉，甚至回来后好几天晚上我都梦到了她，真是让人痛苦，但我为什么最后没有主动一点那，我剖析了好久，觉得可能她并没有喜欢我(真正的感觉))，觉得自己太卑微，觉得她值得更好的，所以有些女孩子，不要轻易拉别人手啊，你一点动静，就让别人兵荒马乱的，其实说起来挺悲哀的，又想吸引别人，又觉得自己不配，想躲避，真是一个丧逼青年。</p>
<p>不想写了，我其实真是个挺丧的人，也很矛盾，人真是一种矛盾综合体，又想别人看到，又觉得让自己躲起来也很好，所以我才把这个东西发在了github，这个没人看的地方，期盼别人看到我，喜欢我，也躲避着别人的目光。</p>
<p>挺丧的，没法期盼未来，只能以痛苦来感受自己还有所行动。也没法期望未来了，就这样吧。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/07/22/java加密/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/07/22/java加密/" class="post-title-link" itemprop="url">java加密</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-22 21:06:53" itemprop="dateCreated datePublished" datetime="2019-07-22T21:06:53+08:00">2019-07-22</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-08-05 00:38:17" itemprop="dateModified" datetime="2019-08-05T00:38:17+08:00">2019-08-05</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="证书概述"><a href="#证书概述" class="headerlink" title="证书概述"></a>证书概述</h2><p>证书主要包括颁发者和被办法者的信息,以及被颁发者的公钥，和CA机构对这些信息的认证，<br>主要内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">**版本**  </span><br><span class="line">识别用于该证书的 X.509 标准的版本，这可以影响证书中所能指定的信息。迄今为止，已定义的版本有三个。  </span><br><span class="line">**序列号**  </span><br><span class="line">发放证书的实体有责任为证书指定序列号，以使其区别于该实体发放的其它证书。此信息用途很多。例如，如果某一证书被撤消，其序列号将放到证书撤消清单 (CRL) 中。  </span><br><span class="line">**签名算法标识符**  </span><br><span class="line">用于识别 CA 签写证书时所用的算法。  </span><br><span class="line">**签发人姓名**  </span><br><span class="line">签写证书的实体的 X.500 名称。它通常为一个 CA。 使用该证书意味着信任签写该证书的实体（注意：有些情况下（例如根或顶层 CA 证书），签发人会签写自己的证书）。  </span><br><span class="line">**有效期**  </span><br><span class="line">每个证书均只能在一个有限的时间段内有效。该有效期以起始日期和时间及终止日期和时间表示，可以短至几秒或长至一世纪。所选有效期取决于许多因素，例如用于签写证书的私钥的使用频率及愿为证书支付的金钱等。它是在没有危及相关私钥的条件下，实体可以依赖公钥值的预计时间。  </span><br><span class="line">**主体名**  </span><br><span class="line">证书可以识别其公钥的实体名。此名称使用 X.500 标准，因此在Internet中应是唯一的。它是实体的特征名 (DN)，例如，</span><br><span class="line">CN=Java Duke，OU=Java Software Division，O=Sun Microsystems Inc，C=US</span><br><span class="line">（这些指主体的通用名、组织单位、组织和国家）。  </span><br><span class="line">**主体公钥信息**  </span><br><span class="line">这是被命名实体的公钥，同时包括指定该密钥所属公钥密码系统的算法标识符及所有相关的密钥参数。</span><br></pre></td></tr></table></figure></p>
<p>PEM DER 只是编码方式，注意并不指定是<strong>证书</strong>的编码方式，也可以是密钥的编码方式</p>
<h2 id="各种名词和文件后缀"><a href="#各种名词和文件后缀" class="headerlink" title="各种名词和文件后缀"></a>各种名词和文件后缀</h2><ol>
<li><p>X.509 - 这是一种证书标准,主要定义了证书中应该包含哪些内容.</p>
</li>
<li><p>两种编码方式：</p>
</li>
</ol>
<ul>
<li><p>PEM - Privacy Enhanced Mail,打开看文本格式,以”—–BEGIN…”开头, “—–END…”结尾,内容是BASE64编码.<br>查看PEM格式证书的信息:openssl x509 -in certificate.pem -text -noout<br>Apache和*NIX服务器偏向于使用这种编码格式.</p>
</li>
<li><p>DER - Distinguished Encoding Rules,打开看是二进制格式,不可读.<br>查看DER格式证书的信息:openssl x509 -in certificate.der -inform der -text -noout<br>Java和Windows服务器偏向于使用这种编码格式.</p>
</li>
</ul>
<ol start="3">
<li>各种文件拓展名：</li>
</ol>
<ul>
<li>CRT - CRT应该是certificate的三个字母,其实还是证书的意思,常见于*NIX系统,有可能是PEM编码,也有可能是DER编码,大多数应该是PEM编码</li>
<li>CER - 还是certificate,还是证书,常见于Windows系统,同样的,可能是PEM编码,也可能是DER编码,大多数应该是DER编码.</li>
<li><p>KEY - 通常用来存放一个公钥或者私钥,<strong>并非X.509证书</strong>,编码同样的,可能是PEM,也可能是DER.</p>
</li>
<li><p>CSR - Certificate Signing Request,即证书签名请求,这个并不是证书,而是向权威证书颁发机构获得签名证书的申请,其核心内容是一个公钥(当然还附带了一些别的信息),在生成这个申请的时候,同时也会生成一个私钥</p>
</li>
<li><p>PFX/P12 - predecessor of PKCS#12,对*nix服务器来说,一般CRT和KEY是分开存放在不同文件中的,但Windows的IIS则将它们存在一个PFX文件中,(因此这个文件包含了证书及私钥)这样会不会不安全？应该不会,PFX通常会有一个”提取密码”</p>
</li>
</ul>
<blockquote>
<p>总结起来：crt cer约等于x509证书，key保存公钥或私钥，csr是证书签名请求，pfx包含证书和私钥</p>
</blockquote>
<ol start="4">
<li>PKCS系列<br>当我发现还有PKCS系列时，我很凌乱，<br>PKCS系列是  Public-Key Cryptography Standards ，是RSA制定的一系列的标准，注意前面写的什么文件后缀啥的，都不算是<strong>标准</strong>，只有X509和PKCS可以称为标准，<br>PKCS中经常使用的就是：PKCS1 PKCS8 PKCS12 </li>
</ol>
<ul>
<li><p>PKCS#1：定义<strong>RSA</strong>公开密钥算法加密和签名机制，主要用于组织PKCS#7中所描述的数字签名和数字信封。 </p>
</li>
<li><p>PKCS#8：描述私有密钥信息格式，该信息包括公开密钥算法的私有密钥以及可选的属性集等。注意pkcs8不只是能表示RSA，所以比PKCS1更具有通用性 </p>
</li>
<li><p>PKCS#12：描述个人信息交换语法标准。描述了将用户公钥、私钥、证书和其他相关信息打包的语法。 </p>
</li>
</ul>
<blockquote>
<p>总结：PKCS1,8,12都可以在某些情况下当作文件格式，PKCS1描述基础的密钥格式，PKCS8也描述密钥，但格式和1不同，PKCS12等价于PFX文件，包含证书和私钥 </p>
</blockquote>
<h2 id="openSSL"><a href="#openSSL" class="headerlink" title="openSSL"></a>openSSL</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"># 生成PKCS#1的公私钥</span><br><span class="line">openssl genrsa -out pkcs1_private.pem 1024</span><br><span class="line">openssl rsa -in pkcs1_private.pem -RSAPublicKey_out -out pkcs1_public.pem</span><br><span class="line"></span><br><span class="line">查看私钥</span><br><span class="line"> openssl rsa -in rsa_private_key.pem -text -noout</span><br><span class="line">查看公钥</span><br><span class="line">openssl rsa -pubin -in  rsa_public_key.pem  -text</span><br><span class="line"></span><br><span class="line"># 由PKCS#1的私钥，生成PKCS#8的公私钥</span><br><span class="line">openssl pkcs8 -topk8 -inform PEM -in pkcs1_private.pem -outform PEM -nocrypt -out from_pkcs1_private_to_pkcs8_private.pem</span><br><span class="line"></span><br><span class="line">openssl rsa -in pkcs1_private.pem -pubout -out from_pkcs1_private_to_pkcs8_public.pem</span><br><span class="line"></span><br><span class="line"># 由PKCS#8的私钥，生成PKCS#1的公私钥</span><br><span class="line">openssl rsa -in from_pkcs1_private_to_pkcs8_private.pem -out from_pkcs8_private_to_pkcs1_private.pem</span><br><span class="line"></span><br><span class="line">openssl rsa -in from_pkcs1_private_to_pkcs8_private.pem -RSAPublicKey_out -out from_pkcs8_private_to_pkcs1_public.pem</span><br><span class="line"></span><br><span class="line"># 由PKCS1公钥生成PKCS#8公钥:</span><br><span class="line">openssl rsa -RSAPublicKey_in -in pkcs1_public.pem -pubout -out from_pkcs1_public_to_pkcs8_public.pem</span><br><span class="line"></span><br><span class="line"># 由PKCS8公钥生成PKCS#1公钥:</span><br><span class="line">openssl rsa -pubin -in from_pkcs1_private_to_pkcs8_public.pem -RSAPublicKey_out -out from_pkcs8_public_to_pkcs1_public.pem</span><br><span class="line"></span><br><span class="line">产生证书请求 注意PKCS1 8都可以</span><br><span class="line">openssl req -new -key private_key.pem -out rsaCerReq.csr</span><br><span class="line"></span><br><span class="line">产生证书 注意PKCS1 8都可以</span><br><span class="line">openssl x509 -req -days 3650 -in rsaCerReq.csr -signkey private_key.pem -out rsaCert.crt</span><br><span class="line"></span><br><span class="line">从证书获得公钥：</span><br><span class="line">openssl x509 -in rsaCert.crt  -noout  -pubkey  &gt; public_key.pem</span><br><span class="line"></span><br><span class="line">生成PKCS12</span><br><span class="line">openssl pkcs12 -export -inkey serverprikey.pem -in server.pem -password pass:&quot;123456&quot; -out server_nocret.pfx</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">从PKCS12获得证书和私钥</span><br><span class="line">openssl pkcs12 -in server_nocret.pfx -nocerts -nodes  -out alicekey.pem</span><br><span class="line"></span><br><span class="line">openssl pkcs12 -in server_nocret.pfx  -nokeys  -out cert.pem</span><br><span class="line"></span><br><span class="line">查看pkcs12内容 -nodes:因为私钥在在输出前会输出加密结果，所以需要nodes来保证不用打密码和不加密</span><br><span class="line">openssl pkcs12 -in server_nocret.pfx -nocerts -nodes  -out alicekey.pem</span><br></pre></td></tr></table></figure>
<h2 id="java-加密体系"><a href="#java-加密体系" class="headerlink" title="java 加密体系"></a>java 加密体系</h2><h2 id="RSA"><a href="#RSA" class="headerlink" title="RSA"></a>RSA</h2><ol>
<li>随机找两个质数 P 和 Q ,定义n= p*q</li>
<li>计算 n 的欧拉函数 m= φ(n) =(p-1)*(1-1),为什么是这样我就不懂了 ，即表示在小于n的数中有多少个与n构成互质,</li>
<li>随机选择一个整数 e，条件是1&lt; e &lt; m，且 e 与 m 互质。</li>
<li>计算d : e*d % m=1 ,虽然是二元一次方程，但通过拓展欧几里得算法可以得出，反正这个算法我也不懂，能算出来就能算出来吧</li>
<li>公钥 （n,e） 私钥（n,d）</li>
</ol>
<p>为什么难以破解：<br>在已知 公钥 N E 的情况下，想要知道 私钥的额D　就需要知道ｍ，而 m=(p-1)(Q-1),想要知道P Q<br>就只能对 N 进行分解，而大整数的因式分解是难以破解的，所以保证了安全</p>
<h2 id="PKCS的结构"><a href="#PKCS的结构" class="headerlink" title="PKCS的结构"></a>PKCS的结构</h2><p>之前我一直奇怪为什么私钥可以转换出公钥，以为是RSA算法的原理所导致，但看起来原理并不满足私钥算出公钥的操作，所以我觉得问题出在PKCS内容上：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">PKCS1 的公钥结构：</span><br><span class="line">RSAPublicKey ::= SEQUENCE &#123;</span><br><span class="line">    modulus           INTEGER,  -- n</span><br><span class="line">    publicExponent    INTEGER   -- e</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PKCS1 的私钥结构：</span><br><span class="line">RSAPrivateKey ::= SEQUENCE &#123;</span><br><span class="line">  version           Version,</span><br><span class="line">  modulus           INTEGER,  -- n</span><br><span class="line">  publicExponent    INTEGER,  -- e</span><br><span class="line">  privateExponent   INTEGER,  -- d</span><br><span class="line">  prime1            INTEGER,  -- p</span><br><span class="line">  prime2            INTEGER,  -- q</span><br><span class="line">  exponent1         INTEGER,  -- d mod (p-1)</span><br><span class="line">  exponent2         INTEGER,  -- d mod (q-1)</span><br><span class="line">  coefficient       INTEGER,  -- (inverse of q) mod p</span><br><span class="line">  otherPrimeInfos   OtherPrimeInfos OPTIONAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PKCS1 公钥：</span><br><span class="line">PublicKeyInfo ::= SEQUENCE &#123;</span><br><span class="line">  algorithm       AlgorithmIdentifier,</span><br><span class="line">  PublicKey       BIT STRING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlgorithmIdentifier ::= SEQUENCE &#123;</span><br><span class="line">  algorithm       OBJECT IDENTIFIER,</span><br><span class="line">  parameters      ANY DEFINED BY algorithm OPTIONAL</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">PKCS8私钥</span><br><span class="line">PrivateKeyInfo ::= SEQUENCE &#123;</span><br><span class="line">  version         Version,</span><br><span class="line">  algorithm       AlgorithmIdentifier,</span><br><span class="line">  PrivateKey      BIT STRING</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">AlgorithmIdentifier ::= SEQUENCE &#123;</span><br><span class="line">  algorithm       OBJECT IDENTIFIER,</span><br><span class="line">  parameters      ANY DEFINED BY algorithm OPTIONAL</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>可以看出PKCS1 的私钥包含了密钥产生的所有元素，所以能算出公钥就不奇怪了，至于PKCS8 看起来不包含，但为什么也可以，我想应该只是结构不同，内容应该都是有的</p>
<h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><blockquote>
<p><a href="https://blog.csdn.net/xy010902100449/article/details/52145009" target="_blank" rel="noopener">https://blog.csdn.net/xy010902100449/article/details/52145009</a><br>注意这个文章的漫画有一个错误的地方，证书并不是CA私钥对公司公钥加密的结果<br>而应该是如下面这个文章的说法，证书=s_KeyPub + s_Info + ca_Info + enc_s_Hash<br>s_KeyPub：公司公钥<br>s_Info：公司信息<br>ca_Info：ca机构<br>enc_s_Hash：ca对公司的认证，=ca_pri(hash(s_KeyPub + s_Info + ca_Info))</p>
</blockquote>
<p>证书在通讯中如何加签和验签，</p>
<blockquote>
<p><a href="https://zhuanlan.zhihu.com/p/36832100" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/36832100</a></p>
</blockquote>
<p>阐述PKCS1 PKCS8的区别,以及PKCS的结构     </p>
<blockquote>
<p><a href="https://www.shangyang.me/2017/05/24/encrypt-rsa-keyformat/" target="_blank" rel="noopener">https://www.shangyang.me/2017/05/24/encrypt-rsa-keyformat/</a></p>
</blockquote>
<p>描述PKCS</p>
<blockquote>
<p><a href="https://qsiofttt.iteye.com/blog/1189487" target="_blank" rel="noopener">https://qsiofttt.iteye.com/blog/1189487</a></p>
</blockquote>
<p>密钥之间转换：</p>
<blockquote>
<p><a href="https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/" target="_blank" rel="noopener">https://xuanxuanblingbling.github.io/ctf/web/2019/05/10/rsa/</a></p>
</blockquote>
<p>RSA:</p>
<blockquote>
<p><a href="https://www.zhihu.com/question/25038691/answer/81565068" target="_blank" rel="noopener">https://www.zhihu.com/question/25038691/answer/81565068</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/07/21/红黑树删除/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/07/21/红黑树删除/" class="post-title-link" itemprop="url">红黑树删除</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-21 00:02:04 / 修改时间：00:08:39" itemprop="dateCreated datePublished" datetime="2019-07-21T00:02:04+08:00">2019-07-21</time>
            

            
              

              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="删除情况图"><a href="#删除情况图" class="headerlink" title="删除情况图"></a>删除情况图</h1><p><img src="/blog/images/红黑树删除情况.png" alt="删除情况"></p>
<h1 id="treemap-删除代码"><a href="#treemap-删除代码" class="headerlink" title="treemap 删除代码"></a>treemap 删除代码</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">deleteEntry</span><span class="params">(Entry&lt;K,V&gt; p)</span> </span>&#123;</span><br><span class="line">    modCount++;</span><br><span class="line">    size--;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 将 有两个子树的 情况 变成  单子树 或叶子 </span></span><br><span class="line">    <span class="keyword">if</span> (p.left != <span class="keyword">null</span> &amp;&amp; p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">        Entry&lt;K,V&gt; s = successor(p);</span><br><span class="line">        p.key = s.key;</span><br><span class="line">        p.value = s.value;</span><br><span class="line">        p = s;</span><br><span class="line">    &#125;  </span><br><span class="line"></span><br><span class="line">    <span class="comment">// </span></span><br><span class="line">    Entry&lt;K,V&gt; replacement = (p.left != <span class="keyword">null</span> ? p.left : p.right);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 一个子树 的情况</span></span><br><span class="line">    <span class="keyword">if</span> (replacement != <span class="keyword">null</span>) &#123;</span><br><span class="line">         </span><br><span class="line">        replacement.parent = p.parent;</span><br><span class="line">        <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>)</span><br><span class="line">            root = replacement;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">            p.parent.left  = replacement;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p.parent.right = replacement;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 等于删掉这个节点</span></span><br><span class="line">        p.left = p.right = p.parent = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 开始平衡</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(replacement);</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (p.parent == <span class="keyword">null</span>) &#123; <span class="comment">//如果删除根节点</span></span><br><span class="line">        root = <span class="keyword">null</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">//  删除叶子节点</span></span><br><span class="line">        <span class="keyword">if</span> (p.color == BLACK)</span><br><span class="line">            fixAfterDeletion(p);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (p.parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p == p.parent.left)</span><br><span class="line">                p.parent.left = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p == p.parent.right)</span><br><span class="line">                p.parent.right = <span class="keyword">null</span>;</span><br><span class="line">            p.parent = <span class="keyword">null</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 入参是 黑叶子，或  单子树里用来代替的子节点</span></span><br><span class="line"><span class="comment">//主要是处理 黑叶子情况，因为单子树的情况连循环都不进</span></span><br><span class="line">   <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fixAfterDeletion</span><span class="params">(Entry&lt;K,V&gt; x)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">while</span> (x != root &amp;&amp; colorOf(x) == BLACK) &#123;</span><br><span class="line">           <span class="keyword">if</span> (x == leftOf(parentOf(x))) &#123;<span class="comment">// 左子树</span></span><br><span class="line">               Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); <span class="comment">//兄弟节点</span></span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (colorOf(sib) == RED) &#123; <span class="comment">//兄弟是红色</span></span><br><span class="line">                   setColor(sib, BLACK);</span><br><span class="line">                   setColor(parentOf(x), RED);</span><br><span class="line">                   rotateLeft(parentOf(x));</span><br><span class="line">                   sib = rightOf(parentOf(x));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (colorOf(leftOf(sib))  == BLACK &amp;&amp;</span><br><span class="line">                   colorOf(rightOf(sib)) == BLACK) &#123; <span class="comment">//兄弟节点此时是黑色， 且两个侄子节点是黑色，</span></span><br><span class="line">                   setColor(sib, RED);</span><br><span class="line">                   x = parentOf(x);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;<span class="comment">//兄弟节点是黑色， 两个侄子节点有一个是红色</span></span><br><span class="line">                   <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK) &#123; <span class="comment">//近侄子是红色</span></span><br><span class="line">                       setColor(leftOf(sib), BLACK);</span><br><span class="line">                       setColor(sib, RED);</span><br><span class="line">                       rotateRight(sib);</span><br><span class="line">                       sib = rightOf(parentOf(x));</span><br><span class="line">                   &#125; <span class="comment">//处理 远侄子是红色的情况，</span></span><br><span class="line">                   setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   setColor(rightOf(sib), BLACK);</span><br><span class="line">                   rotateLeft(parentOf(x));</span><br><span class="line">                   x = root;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123; <span class="comment">// 反转情况，操作一样</span></span><br><span class="line">               Entry&lt;K,V&gt; sib = leftOf(parentOf(x));</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (colorOf(sib) == RED) &#123;</span><br><span class="line">                   setColor(sib, BLACK);</span><br><span class="line">                   setColor(parentOf(x), RED);</span><br><span class="line">                   rotateRight(parentOf(x));</span><br><span class="line">                   sib = leftOf(parentOf(x));</span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (colorOf(rightOf(sib)) == BLACK &amp;&amp;</span><br><span class="line">                   colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                   setColor(sib, RED);</span><br><span class="line">                   x = parentOf(x);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   <span class="keyword">if</span> (colorOf(leftOf(sib)) == BLACK) &#123;</span><br><span class="line">                       setColor(rightOf(sib), BLACK);</span><br><span class="line">                       setColor(sib, RED);</span><br><span class="line">                       rotateLeft(sib);</span><br><span class="line">                       sib = leftOf(parentOf(x));</span><br><span class="line">                   &#125;</span><br><span class="line">                   setColor(sib, colorOf(parentOf(x)));</span><br><span class="line">                   setColor(parentOf(x), BLACK);</span><br><span class="line">                   setColor(leftOf(sib), BLACK);</span><br><span class="line">                   rotateRight(parentOf(x));</span><br><span class="line">                   x = root;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       setColor(x, BLACK);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/07/15/HashMap解析/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/07/15/HashMap解析/" class="post-title-link" itemprop="url">HashMap解析</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-07-15 21:47:46" itemprop="dateCreated datePublished" datetime="2019-07-15T21:47:46+08:00">2019-07-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-21 00:14:02" itemprop="dateModified" datetime="2019-07-21T00:14:02+08:00">2019-07-21</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="重要的参数"><a href="#重要的参数" class="headerlink" title="重要的参数"></a>重要的参数</h2><ol>
<li>static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4 ，默认的初始容量</li>
<li>static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30 ，最大容量</li>
<li>static final float DEFAULT_LOAD_FACTOR = 0.75f 默认的装载因子</li>
<li>static final int TREEIFY_THRESHOLD = 8 在链长度达到这个长度时转换为树结构</li>
<li>static final int UNTREEIFY_THRESHOLD = 6 当长度达到这个长度，会从树转换成链</li>
<li>static final int MIN_TREEIFY_CAPACITY = 64; 想要转换成树的话，table的最小容量</li>
</ol>
<h2 id="field"><a href="#field" class="headerlink" title="field"></a>field</h2><ol>
<li>Node&lt;K,V&gt;[] table;</li>
<li>Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet;</li>
<li>int size;</li>
<li>int modCount; 记录table的修改次数，保证iterators可以快速失败，see ConcurrentModificationException</li>
<li>int threshold 下次扩容的size</li>
<li>float loadFactor; 装载因子</li>
</ol>
<h2 id="内部类"><a href="#内部类" class="headerlink" title="内部类"></a>内部类</h2><ol>
<li><p>Node 基础的node元素</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">Node</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; <span class="keyword">implements</span> <span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt; </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> hash;</span><br><span class="line">        <span class="keyword">final</span> K key;</span><br><span class="line">        V value;</span><br><span class="line">        Node&lt;K,V&gt; next;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KeySet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">K</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>Values</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">Values</span> <span class="keyword">extends</span> <span class="title">AbstractCollection</span>&lt;<span class="title">V</span>&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>EntrySet</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntrySet</span> <span class="keyword">extends</span> <span class="title">AbstractSet</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt; </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>HashIterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">HashIterator</span></span>&#123;</span><br><span class="line">        Node&lt;K,V&gt; next;        <span class="comment">// next entry to return</span></span><br><span class="line">        Node&lt;K,V&gt; current;     <span class="comment">// current entry</span></span><br><span class="line">        <span class="keyword">int</span> expectedModCount;  <span class="comment">// for fast-fail</span></span><br><span class="line">        <span class="keyword">int</span> index;             <span class="comment">// current slot</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>KeyIterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">KeyIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">K</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>ValueIterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">ValueIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">V</span>&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>EntryIterator</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> <span class="class"><span class="keyword">class</span> <span class="title">EntryIterator</span> <span class="keyword">extends</span> <span class="title">HashIterator</span></span></span><br><span class="line"><span class="class">        <span class="keyword">implements</span> <span class="title">Iterator</span>&lt;<span class="title">Map</span>.<span class="title">Entry</span>&lt;<span class="title">K</span>,<span class="title">V</span>&gt;&gt;</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>KeySpliterator</p>
</li>
<li><p>ValueSpliterator</p>
</li>
<li><p>EntrySpliterator</p>
</li>
<li><p>TreeNode</p>
</li>
</ol>
<h2 id="主要行为"><a href="#主要行为" class="headerlink" title="主要行为"></a>主要行为</h2><h3 id="put"><a href="#put" class="headerlink" title="put"></a>put</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> V <span class="title">putVal</span><span class="params">(<span class="keyword">int</span> hash, K key, V value, <span class="keyword">boolean</span> onlyIfAbsent,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">boolean</span> evict)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//n为length, p为 要放入的位置的指针</span></span><br><span class="line">        Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; <span class="keyword">int</span> n, i;</span><br><span class="line">        <span class="keyword">if</span> ((tab = table) == <span class="keyword">null</span> || (n = tab.length) == <span class="number">0</span>)</span><br><span class="line">            n = (tab = resize()).length; <span class="comment">//如果长度为0 则初始化</span></span><br><span class="line">        <span class="keyword">if</span> ((p = tab[i = (n - <span class="number">1</span>) &amp; hash]) == <span class="keyword">null</span>) <span class="comment">//取位置的方式时(len-1) &amp; hash 因为len是2的幂次，所以与运算结果一定小于len</span></span><br><span class="line">            tab[i] = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="comment">//else 发现位置上已经有Node  </span></span><br><span class="line">            Node&lt;K,V&gt; e; K k;</span><br><span class="line">            <span class="keyword">if</span> (p.hash == hash &amp;&amp;</span><br><span class="line">                ((k = p.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k))))</span><br><span class="line">                e = p; <span class="comment">//如果完全一致</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p <span class="keyword">instanceof</span> TreeNode) <span class="comment">//如果p 是TreeNode </span></span><br><span class="line">                e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(<span class="keyword">this</span>, tab, hash, key, value);</span><br><span class="line">            <span class="keyword">else</span> &#123; <span class="comment">//如果p就是正常的Node ,则进行链式的放置</span></span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> binCount = <span class="number">0</span>; ; ++binCount) &#123; </span><br><span class="line">                    <span class="keyword">if</span> ((e = p.next) == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        p.next = newNode(hash, key, value, <span class="keyword">null</span>);</span><br><span class="line">                        <span class="keyword">if</span> (binCount &gt;= TREEIFY_THRESHOLD - <span class="number">1</span>) <span class="comment">// 如果达到了树化的大小 ，则进行树化</span></span><br><span class="line">                            treeifyBin(tab, hash);</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span> (e.hash == hash &amp;&amp;</span><br><span class="line">                        ((k = e.key) == key || (key != <span class="keyword">null</span> &amp;&amp; key.equals(k)))) <span class="comment">//遍历中如果找到equals的Node</span></span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    p = e;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">//此时 e 指向的对象已经是有正确值的Node</span></span><br><span class="line">            <span class="keyword">if</span> (e != <span class="keyword">null</span>) &#123; <span class="comment">// existing mapping for key</span></span><br><span class="line">                V oldValue = e.value;</span><br><span class="line">                <span class="keyword">if</span> (!onlyIfAbsent || oldValue == <span class="keyword">null</span>)  <span class="comment">//判断能否直接替代</span></span><br><span class="line">                    e.value = value;</span><br><span class="line">                afterNodeAccess(e); <span class="comment">//后续操作</span></span><br><span class="line">                <span class="keyword">return</span> oldValue; </span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        ++modCount;  <span class="comment">//这段不是很理解，按理来说在链上增加Node也属于改变Mapping数量，但这段代码看起来只会在直接在table上放值时才会走到</span></span><br><span class="line">        <span class="keyword">if</span> (++size &gt; threshold)</span><br><span class="line">            resize();</span><br><span class="line">        afterNodeInsertion(evict);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<hr>
<p>未完。。。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/05/12/Class文件结构/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/05/12/Class文件结构/" class="post-title-link" itemprop="url">Class文件结构</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-05-12 20:49:45" itemprop="dateCreated datePublished" datetime="2019-05-12T20:49:45+08:00">2019-05-12</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-07-21 00:13:48" itemprop="dateModified" datetime="2019-07-21T00:13:48+08:00">2019-07-21</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="魔数与版本"><a href="#魔数与版本" class="headerlink" title="魔数与版本"></a>魔数与版本</h1><p>魔数，四个字节，唯一作用是确定这个文件是否为一个能被虚拟机接受的Class文件，Class文件的魔数是<br><strong>0xCAFEBABE</strong>,<br>版本号，四个字节，前两个字节是此版本号，后两个字节是主版本号，Java的版本号从45开始，JDK1.1 之后每个大版本号在主版本上向上加1，可以推算jdk8 的主版本号是52，这让我想起来曾经某个JDK版本报错内容： <strong>unsupport version 52</strong> ,<br><img src="/blog/images/Class魔数.png" alt="总览"><br>图为在jdk1.8编译出的class文件的二进制内容</p>
<h1 id="常量池"><a href="#常量池" class="headerlink" title="常量池"></a>常量池</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">此处常量池并不是 Java中的常量，而是class文件中的资源仓库，是占用空间最大的数据项目之一，表数据类型项目，在常量池的入口需要放置一项u2类型的数据，代表常量池容量计数值</span><br><span class="line"></span><br><span class="line">常量池主要存储的是 字面量 和符号引用  ，字面量是类似与Java中常量的存在，类似字符串常量，final，  符号引用是：</span><br><span class="line"></span><br><span class="line">类和接口的全限定名（Fully Qualified Name）</span><br><span class="line">字段的名称和描述符（Descriptor）</span><br><span class="line">方法的名称和描述符</span><br><span class="line"></span><br><span class="line">当虚拟机运行时，需要从常量池获得对应的符号引用，再在类创建时或运行时解析、翻译到具体的内存地址之中</span><br></pre></td></tr></table></figure>
<h1 id="访问标识"><a href="#访问标识" class="headerlink" title="访问标识"></a>访问标识</h1><p>紧接着的两个字节代表访问标志</p>
<h2 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h2><p> Java虚拟机的解释执行引擎被称为”基于栈的执行引擎”，其中所指的栈就是指－操作数栈。</p>
<p>不同于程序计数器，Java虚拟机没有寄存器，程序计数器也无法被程序指令直接访问。Java虚拟机的指令是从操作数栈中而不是从寄存器中取得操作数的，因此它的运行方式是基于栈的而不是基于寄存器的。虽然指令也可以从其他地方取得操作数，比如从字节码流中跟随在操作码（代表指令的字节）之后的字节中或从常量池中，但是主要还是从操作数栈中获得操作数。</p>
<p> 对于基于栈的指令集来说，最大的优势是可移植，因为它的实现不依赖硬件，不足之处在于其运行效率相对于寄存器指令集来说会慢一点；而寄存器指令集的优缺点则刚好与基于栈的指令集相反。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">基于寄存器的：</span><br><span class="line">mov ax, 1 ;把 1 放入寄存器 ax</span><br><span class="line">add ax, 2 ;用 ax 的内容和 2 相加后存入 ax</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">基于栈的</span><br><span class="line">iconst_1 //把整数 1 压入操作数栈</span><br><span class="line">iconst_2 //把整数 2 压入操作数栈</span><br><span class="line">iadd //栈顶的两个数相加后出栈，结果入栈</span><br></pre></td></tr></table></figure>
<p> 指令的操作数分两种：一种是嵌入在指令中的，通常是指令字节后面的若干个字节；另一种是存放在操作数栈中的。为了区别，我们把前者叫做嵌入式操作数，把后者叫做栈内操作数。这两者的区别是：嵌入式操作数是在编译时就已经确定的，运行时不会改变，它和指令一样存放于类文件方法表的 Code 属性中；而操作数是运行时确定的，即程序在执行过程中动态生成的</p>
<ol>
<li>基于栈的执行引擎 是别于寄存器的 执行方式</li>
</ol>
<hr>
<p> 未完。。。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/04/27/性能监控与故障处理工具/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/04/27/性能监控与故障处理工具/" class="post-title-link" itemprop="url">性能监控与故障处理工具</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-27 17:16:11" itemprop="dateCreated datePublished" datetime="2019-04-27T17:16:11+08:00">2019-04-27</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-03 19:05:15" itemprop="dateModified" datetime="2019-05-03T19:05:15+08:00">2019-05-03</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>jdk 所使用的监控工具，主要都是由tools.jar的实现</p>
<h1 id="JPS"><a href="#JPS" class="headerlink" title="JPS"></a>JPS</h1><p>主要作用：用来列出正在执行的虚拟机进程，并显示虚拟机执行的主类名称，以及这些进程在本地虚拟机唯一ID（与操作系统的PID一致），<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">常用参数：</span><br><span class="line">-m  输出启动时的main参数</span><br><span class="line">-v  输出启动时的jvm参数</span><br><span class="line">-l  输出全类名，如果是jar包启动，输出jar路径</span><br></pre></td></tr></table></figure></p>
<h1 id="jstat"><a href="#jstat" class="headerlink" title="jstat"></a>jstat</h1><p>是用于监视虚拟机各种运行状态信息的命令行工具,可显示本地或远程的虚拟机进程的 <strong>类加载，内存，垃圾回收，JIT编译等运行数据</strong>，<br>命令格式<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">jstat -&lt;option&gt; [-t] [-h&lt;lines&gt;] &lt;vmid&gt; [&lt;interval&gt; [&lt;count&gt;]]</span><br><span class="line"></span><br><span class="line">options:</span><br><span class="line">-class</span><br><span class="line">-compiler</span><br><span class="line">-gc</span><br><span class="line">-gccapacity</span><br><span class="line">-gccause</span><br><span class="line">-gcmetacapacity</span><br><span class="line">-gcnew</span><br><span class="line">-gcnewcapacity</span><br><span class="line">-gcold</span><br><span class="line">-gcoldcapacity</span><br><span class="line">-gcutil</span><br><span class="line">-printcompilation</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<blockquote>
<p><a href="https://blog.csdn.net/zhaozheng7758/article/details/8623549" target="_blank" rel="noopener">https://blog.csdn.net/zhaozheng7758/article/details/8623549</a></p>
</blockquote>
<h1 id="jinfo"><a href="#jinfo" class="headerlink" title="jinfo"></a>jinfo</h1><p>可以实时的<strong>查看和修改</strong>虚拟机的各项参数，jps -v也可以看到启动参数，但如果想看一些默认参数，可以使用 jinfo -flag 打印，还可以使用-sysprops选项把虚拟机进程的System.getProperties（）的内容打印出来，-flag name=value修改一部分运行期可写的虚拟机参数值</p>
<h1 id="jmap"><a href="#jmap" class="headerlink" title="jmap"></a>jmap</h1><p>可以打印memory dump文件，比较关键的一个工具，曾经面试被问过，但我那时候只知道+HeapDumpOnOutOfMemoryError 来打印dump<br>其实还有 +HeapDumpOnCtrlBreak参数则可以使用[Ctrl]+[Break]键让虚拟机生成dump文件，又或者在Linux系统下通过Kill-3命令发送进程退出信号“吓唬”一下虚拟机，也能拿到dump文件。<br>jmap的作用并不仅仅是为了获取dump文件，它还可以查询finalize执行队列、Java堆和永久代的详细信息，如空间使用率、当前用的是哪种收集器等</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">jmap -heap 来获得 堆内存情况，</span><br><span class="line">jmap -dump:format=b,file=aaa.dump  18267 打印jvm堆快照文件</span><br></pre></td></tr></table></figure>
<p>此处需要下载 hotspot对应的 debugInfo ，注意小版本也需要相等，</p>
<blockquote>
<p>wget <a href="http://debuginfo.centos.org/7/x86_64/java-1.8.0-openjdk-debuginfo-1.8.0.212.b04-0.el7_6.x86_64.rpm" target="_blank" rel="noopener">http://debuginfo.centos.org/7/x86_64/java-1.8.0-openjdk-debuginfo-1.8.0.212.b04-0.el7_6.x86_64.rpm</a></p>
</blockquote>
<h1 id="jhat"><a href="#jhat" class="headerlink" title="jhat"></a>jhat</h1><p>是一个用来分析jmap生成的内存dump文件的工具，但一般用不到，不如直接使用eclipse MAT </p>
<h1 id="jstack"><a href="#jstack" class="headerlink" title="jstack"></a>jstack</h1><p>用来生成 当前的线程快照， 可以用来确认线程长时间停顿 死锁 占用CPU时间长的原因，会打印出所有的线程的运行状况，</p>
<h1 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h1><p>我起了一个springboot的示例程序来观察内存，<br>使用jstat 查看到：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">NGCMN    NGCMX     NGC     S0C   S1C       EC      OGCMN      OGCMX       OGC         OC       MCMN     MCMX      MC     CCSMN    CCSMX     CCSC    YGC    FGC </span><br><span class="line">5440.0  83968.0   9984.0  960.0  960.0   8064.0    10944.0   167936.0    19848.0    19848.0      0.0 1081344.0  35456.0      0.0 1048576.0   4480.0     80     2</span><br><span class="line"></span><br><span class="line">top:</span><br><span class="line">PID USER      PR  NI    VIRT    RES    SHR S %CPU %MEM     TIME+ COMMAND                                                                                              </span><br><span class="line">18267 wks       20   0 2242.5m 127.8m  13.0m S  0.0 13.1   0:54.99 java</span><br></pre></td></tr></table></figure>
<p>问题在于 OGC +  NGC + MC   !=top 里看到的Java内存大小<br>19848+9984+35456  =   63.7578125‬M<br>这让我很困扰</p>
<p>Conclusion:<br>java进程占用的内存大小并不只是堆内存，且我们没有办法估算 Java 进程占用的RAM内存，因为有太多的因素，<br>比如 栈内存，对外内存，垃圾回收器的RS，<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Total memory = Heap + Code Cache + Metaspace + Symbol tables +</span><br><span class="line">               Other JVM structures + Thread stacks +</span><br><span class="line">               Direct buffers + Mapped files +</span><br><span class="line">               Native Libraries + Malloc overhead + ...</span><br></pre></td></tr></table></figure></p>
<p>参考：</p>
<blockquote>
<p><a href="https://stackoverflow.com/questions/53451103/java-using-much-more-memory-than-heap-size-or-size-correctly-docker-memory-limi" target="_blank" rel="noopener">https://stackoverflow.com/questions/53451103/java-using-much-more-memory-than-heap-size-or-size-correctly-docker-memory-limi</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/04/21/G1学习/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/04/21/G1学习/" class="post-title-link" itemprop="url">G1学习</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-21 20:44:22" itemprop="dateCreated datePublished" datetime="2019-04-21T20:44:22+08:00">2019-04-21</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-03 19:05:14" itemprop="dateModified" datetime="2019-05-03T19:05:14+08:00">2019-05-03</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>之所以单独写一篇是觉得 深入理解JVM虚拟机这本书，对G1细节讲的太少，而且在网上查的资料看起来也很模糊，甚至很有误导性，所以整理了下，但说实话我还是没有理解这个G1完整的过程，将来还是需要慢慢理解整理。</p>
<h1 id="内存分配描述"><a href="#内存分配描述" class="headerlink" title="内存分配描述"></a>内存分配描述</h1><p>G1 的内存不再是像以前一样的连续的内存分布，而是非连续的内存分布<br><img src="/blog/images/g1收集器内存分布.png" alt="g1收集器内存分布"><br>每一块是一个region，可以通过-XX:G1HeapRegionSize指定大小，只能是2的幂等次，<br>H表示的是巨型对象，巨型对象默认是分配在老年区，但是如果是短期的，那么会对老年区造成影响，所以G1划分了H区，如果一个H区放不下，那么会分配连续的空间存放</p>
<h1 id="GC-模式"><a href="#GC-模式" class="headerlink" title="GC 模式"></a>GC 模式</h1><p>共有三种GC模式:  </p>
<ol>
<li>young gc</li>
<li>mixed gc<br> 分为两个部分：  <ol>
<li>global concurrent marking </li>
<li>混合垃圾回收  <strong>STW</strong></li>
</ol>
</li>
<li>full gc  </li>
</ol>
<p>young gc一般是当所有的eden region都被耗尽，就触发一次young gc,执行完一次之后，对象被拷贝survivor 或者old </p>
<p>mixed gc 并不是一个old gc,这是重点， 他会回收整个的young，和部分的old,当老年代达到了内存的阙值时触发</p>
<h2 id="young-gc"><a href="#young-gc" class="headerlink" title="young gc"></a>young gc</h2><p>STW</p>
<p>阶段分为：  </p>
<ol>
<li>根扫描， 静态和本地对象被扫描  </li>
<li>更新RS， 处理dirty card队列更新RS </li>
<li>处理RS， 检测从年轻代指向年老代的对象</li>
<li>对象拷贝，复制到survivor 和old</li>
<li>处理引用队列，软引用，弱引用，虚引用处理</li>
</ol>
<p>其实不是很理解步骤2，3</p>
<p>这里思考一个问题，如果要只收集young, 但young 和old肯定是会有互相引用，难道要扫描全部内存？G1使用了remember set (rset) ,每个region有一个rset，记录谁引用了这块region（point-in）,这个概念在其他收集器中也有体现（资料说是CMS，但我觉得只要分代收集就要用这个），但在之前rset记录的是老年代引用了哪些新生代对象（point-out）,所以直接扫描这块，就不用扫描全部，  </p>
<p>在G1中使用的是ponit-in,记录的是谁引用了这块，因为分区太多，这个rset只记录年老代到新生代的引用，因为每次GC eden都被扫描，</p>
<p>这就又产生一个问题，一个region有很多对象，记录可能会很多 ，所以又产生一个概念，cardTable, 其实就是把一个分区划分为多个区域，rset只记录指向哪个区域，而不是精确到对象</p>
<p><img src="/blog/images/cardTable.png" alt="rset和cardTable">  </p>
<h2 id="mixed-gc"><a href="#mixed-gc" class="headerlink" title="mixed gc"></a>mixed gc</h2><p>选定所有年轻代里的Region，外加根据global concurrent marking统计得出收集收益高的若干老年代Region。在用户指定的开销目标范围内尽可能选择收益高的老年代Region</p>
<p>分为两个步骤：</p>
<ol>
<li>全局并发标记（global concurrent marking）</li>
<li>混合垃圾回收</li>
</ol>
<p>global concurrent marking<strong>主要为mix gc提供标记服务</strong>，并不是必须环节，分为五个步骤：</p>
<ol>
<li>初始标记（initial mark，STW）<br>stop-the-world，它伴随着一次普通的 Young GC 发生，然后对 Survivor 区（root region）进行标记，因为该区可能存在对老年代的引用，因为 Young GC 是需要 stop-the-world 的，所以并发标记直接重用这个阶段</li>
<li>根区域扫描（root region scan）<br>扫描 Survivor 到老年代的引用，该阶段必须在下一次 Young GC 发生前结束  </li>
<li>并发标记（Concurrent Marking）<br>寻找整个堆的存活对象，该阶段可以被 Young GC 中断</li>
<li>最终标记（Remark，STW）<br>stop-the-world，完成最后的存活对象标记。使用了比 CMS 收集器更加高效的 snapshot-at-the-beginning (SATB) 算法</li>
<li>清除垃圾（Cleanup，STW）<br>清除空Region，<strong>即没有存活对象的region</strong>，所以这步不能看作mixgc的清理阶段</li>
</ol>
<p>并发标记结束后是混合垃圾回收周期，不仅进行年轻代垃圾收集，而且回收之前标记出来的老年代的垃圾最多的部分区块。</p>
<p>混合垃圾回收周期会持续进行，直到几乎所有的被标记出来的分区（垃圾占比大的分区）都得到回收，然后恢复到常规的年轻代垃圾收集，最终再次启动并发标记。</p>
<p>所以看起来young gc 和mix gc并不是互斥进行，可以说是同时在进行。</p>
<h2 id="full-gc"><a href="#full-gc" class="headerlink" title="full gc"></a>full gc</h2><p>什么情况会触发full gc（STW收集）：</p>
<ol>
<li>concurrent mode failure：并发模式失败，CMS 收集器也有同样的概念。G1 并发标记期间，如果在标记结束前，老年代被填满，G1 会放弃标记</li>
<li>晋升失败：并发周期结束后，是混合垃圾回收周期，伴随着年轻代垃圾收集，进行清理老年代空间，如果这个时候清理的速度小于消耗的速度，导致老年代不够用，那么会发生晋升失败</li>
<li>疏散失败：年轻代垃圾收集的时候，如果 Survivor 和 Old 区没有足够的空间容纳所有的存活对象。这种情况肯定是非常致命的，因为基本上已经没有多少空间可以用了，这个时候会触发 Full GC 也是很合理的。</li>
</ol>
<h2 id="三色标记法"><a href="#三色标记法" class="headerlink" title="三色标记法"></a>三色标记法</h2><p>TODO 待补全</p>
<h2 id="常用参数"><a href="#常用参数" class="headerlink" title="常用参数"></a>常用参数</h2><p>TODO 待补全</p>
<p>参考：</p>
<blockquote>
<p><a href="http://blog.jobbole.com/109170/" target="_blank" rel="noopener">http://blog.jobbole.com/109170/</a><br><a href="http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/" target="_blank" rel="noopener">http://ifeve.com/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3g1%E5%9E%83%E5%9C%BE%E6%94%B6%E9%9B%86%E5%99%A8/</a><br><a href="https://tech.meituan.com/2016/09/23/g1.html" target="_blank" rel="noopener">https://tech.meituan.com/2016/09/23/g1.html</a> 讲的最好<br><a href="https://juejin.im/entry/5af0832c51882567244deb44" target="_blank" rel="noopener">https://juejin.im/entry/5af0832c51882567244deb44</a></p>
</blockquote>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/04/15/判断对象已死-垃圾回收算法-hotspot实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/04/15/判断对象已死-垃圾回收算法-hotspot实现/" class="post-title-link" itemprop="url">判断对象已死-垃圾回收算法-hotspot实现</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-15 21:13:46" itemprop="dateCreated datePublished" datetime="2019-04-15T21:13:46+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-04 17:22:35" itemprop="dateModified" datetime="2019-05-04T17:22:35+08:00">2019-05-04</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="判断对象已死"><a href="#判断对象已死" class="headerlink" title="判断对象已死"></a>判断对象已死</h1><h2 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h2><p>缺点：无法判断循环引用</p>
<h2 id="可达性分析"><a href="#可达性分析" class="headerlink" title="可达性分析"></a>可达性分析</h2><p>定义：称为<strong>GC Roots</strong>的对象作为起始点，从这些节点开始向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连（用图论的话来说，就是从GC Roots到这个对象不可达）时，则证明此对象是不可用的</p>
<p>GC roots:</p>
<ul>
<li>虚拟机栈（栈帧中的本地变量表）中引用的对象。</li>
<li>方法区中类静态属性引用的对象。</li>
<li>方法区中常量引用的对象。</li>
<li>本地方法栈中JNI（即一般说的Native方法）引用的对象。</li>
</ul>
<h2 id="关于引用"><a href="#关于引用" class="headerlink" title="关于引用"></a>关于引用</h2><p>在jdk1.2 之前，对引用的概念太过于狭窄，我们希望描述一种类型：当内存足够时可以保留，当内存不够时可以抛弃，</p>
<p>jdk1.2之后通过扩展，有了：</p>
<ul>
<li>强引用<blockquote>
<p>正常使用的引用，只要引用还在就永远不会回收</p>
</blockquote>
</li>
<li>软引用<blockquote>
<p>软引用描述<strong>还有用但并非必须的对象</strong>，在<strong>即将抛出OOM</strong>之前进行回收，如果回收之后还无法获得足够的空间就OOM,提供了softReference来实现软引用</p>
</blockquote>
</li>
<li>弱引用<blockquote>
<p>被弱引用关联的对象只存活到下一次GC就会被回收，提供weakReference来实现</p>
</blockquote>
</li>
<li>虚引用<blockquote>
<p>最弱的一种引用关系。一个对象是否有虚引用的存在，完全不会对其生存时间构成影响，也无法通过虚引用来取得一个对象实例。为一个对象设置虚引用关联的唯一目的就是能在这个对象被收集器回收时收到一个系统通知,提供PhantomReference来实现。</p>
</blockquote>
</li>
</ul>
<h2 id="finalize"><a href="#finalize" class="headerlink" title="finalize"></a>finalize</h2><p>当一个对象被可达性分析判断可以GC，那么将会被标记，如果该对象覆盖了finalize方法，那么将会把对象放在F-queue队列，等待一个低优先级的Finalize线程来执行finalize方法，但注意如果对象的finalize方法中又使得对象和应用链中的对象重新建立了联系，<br>注意的点：</p>
<ol>
<li>这是因为任何一个对象的finalize（）方法都只会被系统自动调用一次，如果对象面临下一次回收，它的finalize（）方法不会被再次执行</li>
<li>finalize方法的用途是为了处理<strong>关闭外部资源</strong>，所以大多数情况并不需要主要这个方法</li>
</ol>
<h2 id="永久区（方法区）对象判断"><a href="#永久区（方法区）对象判断" class="headerlink" title="永久区（方法区）对象判断"></a>永久区（方法区）对象判断</h2><p>方法区的回收主要是常量和类对象的回收，判断常量是否可回收，是检测是否还有对象引用常量，而判断类的可回收，条件如下</p>
<ol>
<li>该类的所有对象都被回收。</li>
<li>加载该类的classLoardor被回收</li>
<li>该类的class对象没有被引用<blockquote>
<p>HotSpot虚拟机提供了-Xnoclassgc参数进行控制，还可以使用-verbose：class以及-XX：+TraceClassLoading、-XX：+TraceClassUnLoading查看类加载和卸载信息，其中-verbose：class和-XX：+TraceClassLoading可以在Product版的虚拟机中使用，-XX：+TraceClassUnLoading参数需要FastDebug版的虚拟机支持</p>
</blockquote>
</li>
</ol>
<p>对于大量使用classLoader ，如反射，cglib的框架，都需要设定这个参数来保证永久区不会溢出（这让我回想起曾经的热加载）</p>
<h1 id="垃圾回收算法"><a href="#垃圾回收算法" class="headerlink" title="垃圾回收算法"></a>垃圾回收算法</h1><h2 id="标记清除"><a href="#标记清除" class="headerlink" title="标记清除"></a>标记清除</h2><p>是最基础的回收算法，别的很多算法都基于这个思想，分为两个阶段，标记-清除，具体过程是标记后统一清除。<br>缺点：</p>
<ol>
<li>效率不高</li>
<li>空间问题，如果没有整理，会产生大量的空间碎片，影响到分配大对象</li>
</ol>
<h2 id="复制算法"><a href="#复制算法" class="headerlink" title="复制算法"></a>复制算法</h2><p>为了解决<strong>效率问题和碎片问题</strong>，将内存分为两个部分，每次new对象只放在一边，满了之后将还存活的对象复制到另一边，再清理掉旧的一边的内存，解决了<strong>碎片</strong>问题。现代垃圾回收采用这种算法来处理<strong>新生代</strong>区域内存。</p>
<p>原因是：新生代的内存<strong>朝生夕死</strong>，意味着它的存活很短，大部分对象都是需要被gc的，所以并不需要1：1的方式划分新生代，</p>
<blockquote>
<p>而是将内存分为一块较大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor。当回收时，将Eden和Survivor中还存活着的对象一次性地复制到另外一块Survivor空间上，最后清理掉Eden和刚才用过的Survivor空间。HotSpot虚拟机默认Eden和Survivor的大小比例是<strong>8:1</strong>，也就是每次新生代中可用内存空间为整个新生代容量的90%（80%+10%），只有10%的内存会被“浪费”</p>
</blockquote>
<h2 id="标记整理算法"><a href="#标记整理算法" class="headerlink" title="标记整理算法"></a>标记整理算法</h2><p>对于老年代，对象存活时间长，如果不想浪费50%的空间，就需要有额外的空间进行分配担保，以应对被使用的内存中所有对象都100%存活的极端情况，所以在老年代一般不能直接选用这种算法</p>
<blockquote>
<p>分配担保指的是复制算法中如果一边内存的对象被复制去另一边的时候发现另一边空间不够，就需要有另一块内存来保证可以被使用，</p>
</blockquote>
<p>所以提出标记整理算法，过程是先标记，然后让所有存活的对象都像另一端移动，然后清理掉端边界以外的内存，</p>
<h2 id="分代回收"><a href="#分代回收" class="headerlink" title="分代回收"></a>分代回收</h2><p>根据对象的存活周期将内存划分为不同区域（新生代，老年代），对不同的区域采用不同的回收算法</p>
<p>对于新生代，对象存活时间短，所以可以使用复制算法，而对于老年代，存活时间长，可以使用标记清除或者标记整理算法。</p>
<h1 id="Hotspot的实现"><a href="#Hotspot的实现" class="headerlink" title="Hotspot的实现"></a>Hotspot的实现</h1><h2 id="枚举根节点"><a href="#枚举根节点" class="headerlink" title="枚举根节点"></a>枚举根节点</h2><p>可达性分析的难点：</p>
<ul>
<li>目前方法区的范围太大，检查引用会消耗太大的时间</li>
<li>因为并发，导致检查这个步骤必须stop the world </li>
</ul>
<p>hotspot的实现上，使用准确式GC，即JVM知道内存当中某位置存放什么样的数据，使用oopMap(ordinary Object Pointer Map)普通对象指明Map,在类加载完成之后，JVM 就记录了这个对象实例的多少偏移量存放的是什么类型数据，这样GC的时候就可以直接使用oopMap 来得到引用信息。</p>
<h2 id="安全点"><a href="#安全点" class="headerlink" title="安全点"></a>安全点</h2><p>维护oopMap 非常困难（因为并发，而且改变引用是很容易的事），所以hotspot 使用了安全点的概念，安全点可以抽象的看作当前系统运行的一个时间点，在这个时间点进行oopMap 更新和GC，安全点的选择是<strong>是否具有让程序长时间执行的特征</strong>为标准选择</p>
<blockquote>
<p>因为每条指令执行的时间都非常短暂，程序不太可能因为指令流长度太长这个原因而过长时间运行，“长时间执行”的最明显特征就是指令序列复用，例如方法调用、循环跳转、异常跳转等，所以具有这些功能的指令才会产生Safepoint</p>
</blockquote>
<p>这就产生一个问题，在进行GC时会stop the world 来进行可达性分析，那么现在使用了安全点来标记gc的时间点，所以就需要所有线程在进行gc前跑到安全点上（但是否是”所有”线程），有两种方案：</p>
<ul>
<li>抢先式中断</li>
<li>主动式中断</li>
</ul>
<p>抢先式中断<strong>在GC发生时</strong>把所有线程中断，如果发现有线程中断的地方不在安全点，就激活线程，这种方式几乎没有虚拟机使用</p>
<p>主动式中断是当需要GC的时候，不主动中断线程，而是设置标志位，线程轮询标准位来判断是否挂起，而轮询的位置就是安全点位置，和分配对象内存的位置，</p>
<h2 id="安全区域"><a href="#安全区域" class="headerlink" title="安全区域"></a>安全区域</h2><p>安全点没办法解决<strong>当程序</strong>不分配CPU的时候，即程序sleep或blocked的时候，这时无法到达安全点和响应<strong>中断</strong>，就需要安全区域的概念</p>
<p>简单描述就是在一段代码中，引用关系不变的话，就属于safe region ，在这个区域中进行GC都是可以的，线程会标识自己进入safe region ,这样当进行GC的时候，就不用管这些线程了</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/blog/blog/2019/04/15/垃圾回收器/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="wks">
      <meta itemprop="description" content>
      <meta itemprop="image" content="/blog/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="wks藏在这里">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                
                <a href="/blog/2019/04/15/垃圾回收器/" class="post-title-link" itemprop="url">垃圾回收器</a>
              
            
          </h1>
        

        <div class="post-meta">
          <span class="post-time">

            
            
            

            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              

              
                
              

              <time title="创建时间：2019-04-15 21:13:46" itemprop="dateCreated datePublished" datetime="2019-04-15T21:13:46+08:00">2019-04-15</time>
            

            
              

              
                
                <span class="post-meta-divider">|</span>
                

                <span class="post-meta-item-icon">
                  <i class="fa fa-calendar-check-o"></i>
                </span>
                
                  <span class="post-meta-item-text">更新于</span>
                
                <time title="修改时间：2019-05-03 19:05:17" itemprop="dateModified" datetime="2019-05-03T19:05:17+08:00">2019-05-03</time>
              
            
          </span>

          

          
            
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="使用场景总览"><a href="#使用场景总览" class="headerlink" title="使用场景总览"></a>使用场景总览</h1><p><img src="/blog/images/垃圾收集器的使用场景.png" alt="总览"></p>
<h1 id="serial-收集器"><a href="#serial-收集器" class="headerlink" title="serial 收集器"></a>serial 收集器</h1><ol start="0">
<li>可以使用在新生代</li>
<li>单线程</li>
<li>进行收集操作的时候 stop the world </li>
<li>使用<strong>复制算法</strong>  </li>
</ol>
<h1 id="serial-old"><a href="#serial-old" class="headerlink" title="serial_old"></a>serial_old</h1><ol start="0">
<li>老年代版本的serial 收集器</li>
<li>单线程 </li>
<li>使用<strong>标记-整理</strong>算法  </li>
<li>主要用途是在jdk1.5 之前parallel scavenge配合，还有作为CMS的后备收集器，在并发收集时发生concurrent Mode Failure时使用，</li>
</ol>
<h1 id="ParNew-收集器"><a href="#ParNew-收集器" class="headerlink" title="ParNew 收集器"></a>ParNew 收集器</h1><ol start="0">
<li>用在新生代，使用<strong>复制</strong>算法</li>
<li>serial的多线程版本，</li>
<li>新生代的首选，除了serial,只有他可以和CMS配合使用，实际上，在CMS作为老年代收集器后新生代只能选择serial和parNew</li>
<li>-XX：ParallelGCThreads可以限制回收的线程数</li>
</ol>
<h1 id="Parallel-Scavenge"><a href="#Parallel-Scavenge" class="headerlink" title="Parallel Scavenge"></a>Parallel Scavenge</h1><ol start="0">
<li>用在新生代，使用<strong>复制</strong>算法,使用多线程</li>
<li>别的收集器关注点在于降低STW的时间，而Parallel Scavenge关注的是吞吐量，吞吐量=运行用户代码时间/（用户代码时间+垃圾回收时间）</li>
<li>Parallel Scavenge收集器提供了两个参数用于精确控制吞吐量，分别是控制最大垃圾收集停顿时间的-XX：MaxGCPauseMillis参数以及直接设置吞吐量大小的-XX：GCTimeRatio参数。</li>
<li><strong>-XX：+UseAdaptiveSizePolicy</strong> 就不需要手工指定新生代的大小（-Xmn）、Eden与Survivor区的比例（-XX：SurvivorRatio）、晋升老年代对象年龄（-XX：PretenureSizeThreshold）等细节参数了，虚拟机会根据当前系统的运行情况收集性能监控信息，动态调整这些参数以提供最合适的停顿时间或者最大的吞吐量</li>
<li>无法与CMS配合使用，原因是Parallel Scavenge没有使用原本HotSpot其它GC通用的那个GC框架，所以不能跟使用了那个框架的CMS搭配使用</li>
</ol>
<h1 id="parallel-scavenge-old"><a href="#parallel-scavenge-old" class="headerlink" title="parallel scavenge old"></a>parallel scavenge old</h1><ol start="0">
<li>用在老年代，多线程，<strong>标记整理</strong>算法</li>
<li>在1.6后提供，在此之前都只能使用serial_old作为老年代来配合parallel scavenge，效率并不高</li>
</ol>
<h1 id="CMS"><a href="#CMS" class="headerlink" title="CMS"></a>CMS</h1><ol start="0">
<li>目的时减少停顿时间，用于老年区</li>
<li><blockquote>
<p>阶段包括：<br> 1.初始标记。标记下GC ROOT直接可达的对象，速度快<br> 2.并发标记。进行GC root trace<br> 3.重新标记. 是为了修正并发标记期间用户程序运行产生的垃圾变动，<br> 4.并发清除<br> 初始标记，重新标记仍然需要STW，</p>
</blockquote>
</li>
<li>缺点：  <ol>
<li>无法处理浮动垃圾，即在并发清除时产生的垃圾，出现concurrent mode failure,所以CMS需要给并发清除预留一部分内存，所以CMS不能像别的收集器一样满了之后才运行，而是在达到阙值后就启动，-XX：CMSInitiatingOccupancyFraction可以设置阙值  </li>
<li>由于基于标记清除算法，所以可能出现太多碎片，导致大的对象无法分配内存，为了处理这种情况，提供-XX：+UseCMSCompactAtFullCollection ，在每次FUll GC之前进行，碎片整理，和XX：CMSFullGCsBeforeCompaction，这个参数是用于设置执行多少次不压缩的Full GC后，跟着来一次带压缩的</li>
</ol>
</li>
</ol>
<h1 id="G1收集器"><a href="#G1收集器" class="headerlink" title="G1收集器"></a>G1收集器</h1><p>在内存上将内存分为大小相等的region，新生代和老年代都是一部分<strong>不需要连续的</strong>的region，G1 可以有计划的避免在整个堆中进行回收，而是维护一个优先队列，每次根据运行的时间，优先回收价值最大的region，  </p>
<p>这里作者提出一个问题：如果分为region，那么每个region里的对象肯定不是孤立的，而是互相有依赖，那么如果想回收新生代，岂不是也要扫描老年代？实际上G1和其他收集器在虚拟机中都是使用remembered set 来记录引用关系，如果虚拟机检测到对引用的修改，那么就立刻更新remembered set ,这样就可以保证不需要扫描全内存。</p>
<ol start="0">
<li>G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去处理新创建的对象和已经存活了一段时间、熬过多次GC的旧对象以获取更好的收集效果</li>
<li>G1从整体来看是基于<strong>标记—整理</strong>算法实现的收集器，从局部（两个Region之间）上来看是基于<strong>复制</strong>算法实现的，但无论如何，这两种算法都意味着G1运作期间不会产生内存空间碎片</li>
<li>停顿时间可预测，能让使用者明确指定在一个长度为M毫秒的时间片段内，消耗在垃圾收集上的时间不得超过N毫秒 ， </li>
<li><p>操作主要包括：<br> 1.初始标记，标记GC root直接可达的对象，并改变next top at mark start,STW，时间很短<br> 2.并发标记，进行可达性分析，将引用的变化情况记录在remembered set log<br> 3.最终标记，将remember set log 和remember set合并，STW<br> 4.筛选回收，也可以停顿也可以并行，主要对region回收价值排序，并在用户指定的停顿时间来制定回收计划  </p>
</li>
<li><p>相对于CMS，碎片更少空间利用更高，停顿时间可控，</p>
</li>
</ol>
<h1 id="关于吞吐率和停顿时间"><a href="#关于吞吐率和停顿时间" class="headerlink" title="关于吞吐率和停顿时间　　"></a>关于吞吐率和停顿时间　　</h1><p>停顿时间越短就越适合需要与用户交互的程序，良好的响应速度能提升用户体验，而高吞吐量则可以高效率地利用CPU时间，尽快完成程序的运算任务，主要适合在后台运算而不需要太多交互的任务,<br>看到parallel scavenge 注重的时吞吐率，而其他收集器注重停顿时间，觉得这两个不应该是同一种东西吗，减少了停顿时间不就提高了吞吐率吗，但这俩个应该算是两个维度，GC的时间应该是停顿时间的超集。</p>

          
        
      
    </div>

    

    
    
    

    

    
      
    
    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <div class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">wks</p>
              <div class="site-description motion-element" itemprop="description"></div>
          </div>

          
            <nav class="site-state motion-element">
              
                <div class="site-state-item site-state-posts">
                
                  <a href="/blog/archives/">
                
                    <span class="site-state-item-count">9</span>
                    <span class="site-state-item-name">日志</span>
                  </a>
                </div>
              

              

              
                
                
                <div class="site-state-item site-state-tags">
                  
                    
                    
                      
                    
                      
                    
                      
                    
                    <span class="site-state-item-count">3</span>
                    <span class="site-state-item-name">标签</span>
                  
                </div>
              
            </nav>
          

          

          

          

          

          
          

          
            
          
          

        </div>
      </div>

      

      

    </div>
  </aside>
  


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2019</span>
  <span class="with-love" id="animate">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">wks</span>

  

  
</div>


  <div class="powered-by">由 <a href="https://hexo.io" class="theme-link" rel="noopener" target="_blank">Hexo</a> 强力驱动 v3.8.0</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 – <a href="https://theme-next.org" class="theme-link" rel="noopener" target="_blank">NexT.Muse</a> v7.1.0</div>




        








        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    

    
  </div>

  

<script>
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>


























  
  <script src="/blog/lib/jquery/index.js?v=2.1.3"></script>

  
  <script src="/blog/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script src="/blog/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>


  


  <script src="/blog/js/utils.js?v=7.1.0"></script>

  <script src="/blog/js/motion.js?v=7.1.0"></script>



  
  


  <script src="/blog/js/schemes/muse.js?v=7.1.0"></script>



  

  


  <script src="/blog/js/next-boot.js?v=7.1.0"></script>


  

  

  

  



  




  

  

  

  

  

  

  

  

  

  

  

  

  

  

</body>
</html>
